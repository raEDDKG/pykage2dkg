{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "emoji",
  "description": "",
  "programmingLanguage": "Python",
  "hasPart": [
    {
      "@type": "CodeFile",
      "name": "tokenizer.py",
      "programmingLanguage": "Python",
      "text": "\"\"\"\nemoji.tokenizer\n~~~~~~~~~~~~~~~\n\nComponents for detecting and tokenizing emoji in strings.\n\n\"\"\"\n\nfrom typing import List, NamedTuple, Dict, Union, Iterator, Any\nfrom emoji import unicode_codes\n\n\n__all__ = [\n    'EmojiMatch',\n    'EmojiMatchZWJ',\n    'EmojiMatchZWJNonRGI',\n    'Token',\n    'tokenize',\n    'filter_tokens',\n]\n\n_ZWJ = '\\u200d'\n_SEARCH_TREE: Dict[str, Any] = {}\n\n\nclass EmojiMatch:\n    \"\"\"\n    Represents a match of a \"recommended for general interchange\" (RGI)\n    emoji in a string.\n    \"\"\"\n\n    __slots__ = ('emoji', 'start', 'end', 'data')\n\n    def __init__(\n        self, emoji: str, start: int, end: int, data: Union[Dict[str, Any], None]\n    ):\n        self.emoji = emoji\n        \"\"\"The emoji substring\"\"\"\n\n        self.start = start\n        \"\"\"The start index of the match in the string\"\"\"\n\n        self.end = end\n        \"\"\"The end index of the match in the string\"\"\"\n\n        self.data = data\n        \"\"\"The entry from :data:`EMOJI_DATA` for this emoji or ``None`` if the emoji is non-RGI\"\"\"\n\n    def data_copy(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns a copy of the data from :data:`EMOJI_DATA` for this match\n        with the additional keys ``match_start`` and ``match_end``.\n        \"\"\"\n        if self.data:\n            emj_data = self.data.copy()\n            emj_data['match_start'] = self.start\n            emj_data['match_end'] = self.end\n            return emj_data\n        else:\n            return {'match_start': self.start, 'match_end': self.end}\n\n    def is_zwj(self) -> bool:\n        \"\"\"\n        Checks if this is a ZWJ-emoji.\n\n        :returns: True if this is a ZWJ-emoji, False otherwise\n        \"\"\"\n\n        return _ZWJ in self.emoji\n\n    def split(self) -> Union['EmojiMatchZWJ', 'EmojiMatch']:\n        \"\"\"\n        Splits a ZWJ-emoji into its constituents.\n\n        :returns: An :class:`EmojiMatchZWJ` containing the \"sub-emoji\" if this is a ZWJ-emoji, otherwise self\n        \"\"\"\n\n        if self.is_zwj():\n            return EmojiMatchZWJ(self)\n        else:\n            return self\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}({self.emoji}, {self.start}:{self.end})'\n\n\nclass EmojiMatchZWJ(EmojiMatch):\n    \"\"\"\n    Represents a match of multiple emoji in a string that were joined by\n    zero-width-joiners (ZWJ/``\\\\u200D``).\"\"\"\n\n    __slots__ = ('emojis',)\n\n    def __init__(self, match: EmojiMatch):\n        super().__init__(match.emoji, match.start, match.end, match.data)\n\n        self.emojis: List[EmojiMatch] = []\n        \"\"\"List of sub emoji as EmojiMatch objects\"\"\"\n\n        i = match.start\n        for e in match.emoji.split(_ZWJ):\n            m = EmojiMatch(e, i, i + len(e), unicode_codes.EMOJI_DATA.get(e, None))\n            self.emojis.append(m)\n            i += len(e) + 1\n\n    def join(self) -> str:\n        \"\"\"\n        Joins a ZWJ-emoji into a string\n        \"\"\"\n\n        return _ZWJ.join(e.emoji for e in self.emojis)\n\n    def is_zwj(self) -> bool:\n        return True\n\n    def split(self) -> 'EmojiMatchZWJ':\n        return self\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}({self.join()}, {self.start}:{self.end})'\n\n\nclass EmojiMatchZWJNonRGI(EmojiMatchZWJ):\n    \"\"\"\n    Represents a match of multiple emoji in a string that were joined by\n    zero-width-joiners (ZWJ/``\\\\u200D``). This class is only used for emoji\n    that are not \"recommended for general interchange\" (non-RGI) by Unicode.org.\n    The data property of this class is always None.\n    \"\"\"\n\n    def __init__(self, first_emoji_match: EmojiMatch, second_emoji_match: EmojiMatch):\n        self.emojis = [first_emoji_match, second_emoji_match]\n        \"\"\"List of sub emoji as EmojiMatch objects\"\"\"\n\n        self._update()\n\n    def _update(self):\n        self.emoji = _ZWJ.join(e.emoji for e in self.emojis)\n        self.start = self.emojis[0].start\n        self.end = self.emojis[-1].end\n        self.data = None\n\n    def _add(self, next_emoji_match: EmojiMatch):\n        self.emojis.append(next_emoji_match)\n        self._update()\n\n\nclass Token(NamedTuple):\n    \"\"\"\n    A named tuple containing the matched string and its :class:`EmojiMatch` object if it is an emoji\n    or a single character that is not a unicode emoji.\n    \"\"\"\n\n    chars: str\n    value: Union[str, EmojiMatch]\n\n\ndef tokenize(string: str, keep_zwj: bool) -> Iterator[Token]:\n    \"\"\"\n    Finds unicode emoji in a string. Yields all normal characters as a named\n    tuple :class:`Token` ``(char, char)`` and all emoji as :class:`Token` ``(chars, EmojiMatch)``.\n\n    :param string: String contains unicode characters. MUST BE UNICODE.\n    :param keep_zwj: Should ZWJ-characters (``\\\\u200D``) that join non-RGI emoji be\n        skipped or should be yielded as normal characters\n    :return: An iterable of tuples :class:`Token` ``(char, char)`` or :class:`Token` ``(chars, EmojiMatch)``\n    \"\"\"\n\n    tree = get_search_tree()\n    EMOJI_DATA = unicode_codes.EMOJI_DATA\n    # result: [ Token(oldsubstring0, EmojiMatch), Token(char1, char1), ... ]\n    result: List[Token] = []\n    i = 0\n    length = len(string)\n    ignore: List[\n        int\n    ] = []  # index of chars in string that are skipped, i.e. the ZWJ-char in non-RGI-ZWJ-sequences\n    while i < length:\n        consumed = False\n        char = string[i]\n        if i in ignore:\n            i += 1\n            if char == _ZWJ and keep_zwj:\n                result.append(Token(char, char))\n            continue\n\n        elif char in tree:\n            j = i + 1\n            sub_tree = tree[char]\n            while j < length and string[j] in sub_tree:\n                if j in ignore:\n                    break\n                sub_tree = sub_tree[string[j]]\n                j += 1\n            if 'data' in sub_tree:\n                emj_data = sub_tree['data']\n                code_points = string[i:j]\n\n                # We cannot yield the result here, we need to defer\n                # the call until we are sure that the emoji is finished\n                # i.e. we're not inside an ongoing ZWJ-sequence\n                match_obj = EmojiMatch(code_points, i, j, emj_data)\n\n                i = j - 1\n                consumed = True\n                result.append(Token(code_points, match_obj))\n\n        elif (\n            char == _ZWJ\n            and result\n            and result[-1].chars in EMOJI_DATA\n            and i > 0\n            and string[i - 1] in tree\n        ):\n            # the current char is ZWJ and the last match was an emoji\n            ignore.append(i)\n            if (\n                EMOJI_DATA[result[-1].chars]['status']\n                == unicode_codes.STATUS['component']\n            ):\n                # last match was a component, it could be ZWJ+EMOJI+COMPONENT\n                # or ZWJ+COMPONENT\n                i = i - sum(len(t.chars) for t in result[-2:])\n                if string[i] == _ZWJ:\n                    # It's ZWJ+COMPONENT, move one back\n                    i += 1\n                    del result[-1]\n                else:\n                    # It's ZWJ+EMOJI+COMPONENT, move two back\n                    del result[-2:]\n            else:\n                # last match result[-1] was a normal emoji, move cursor\n                # before the emoji\n                i = i - len(result[-1].chars)\n                del result[-1]\n            continue\n\n        elif result:\n            yield from result\n            result = []\n\n        if not consumed and char != '\\ufe0e' and char != '\\ufe0f':\n            result.append(Token(char, char))\n        i += 1\n\n    yield from result\n\n\ndef filter_tokens(\n    matches: Iterator[Token], emoji_only: bool, join_emoji: bool\n) -> Iterator[Token]:\n    \"\"\"\n    Filters the output of `tokenize()`\n\n    :param matches: An iterable of tuples of the form ``(match_str, result)``\n        where ``result`` is either an EmojiMatch or a string.\n    :param emoji_only: If True, only EmojiMatch are returned in the output.\n        If False all characters are returned\n    :param join_emoji: If True, multiple EmojiMatch are merged into\n        a single :class:`EmojiMatchZWJNonRGI` if they are separated only by a ZWJ.\n\n    :return: An iterable of tuples :class:`Token` ``(char, char)``,\n        :class:`Token` ``(chars, EmojiMatch)`` or :class:`Token` ``(chars, EmojiMatchZWJNonRGI)``\n    \"\"\"\n\n    if not join_emoji and not emoji_only:\n        yield from matches\n        return\n\n    if not join_emoji:\n        for token in matches:\n            if token.chars != _ZWJ:\n                yield token\n        return\n\n    # Combine multiple EmojiMatch that are separated by ZWJs into\n    # a single EmojiMatchZWJNonRGI\n    previous_is_emoji = False\n    previous_is_zwj = False\n    pre_previous_is_emoji = False\n    accumulator: List[Token] = []\n    for token in matches:\n        pre_previous_is_emoji = previous_is_emoji\n        if previous_is_emoji and token.value == _ZWJ:\n            previous_is_zwj = True\n        elif isinstance(token.value, EmojiMatch):\n            if pre_previous_is_emoji and previous_is_zwj:\n                if isinstance(accumulator[-1].value, EmojiMatchZWJNonRGI):\n                    accumulator[-1].value._add(token.value)  # pyright: ignore [reportPrivateUsage]\n                    accumulator[-1] = Token(\n                        accumulator[-1].chars + _ZWJ + token.chars,\n                        accumulator[-1].value,\n                    )\n                else:\n                    prev = accumulator.pop()\n                    assert isinstance(prev.value, EmojiMatch)\n                    accumulator.append(\n                        Token(\n                            prev.chars + _ZWJ + token.chars,\n                            EmojiMatchZWJNonRGI(prev.value, token.value),\n                        )\n                    )\n            else:\n                accumulator.append(token)\n            previous_is_emoji = True\n            previous_is_zwj = False\n        else:\n            # Other character, not an emoji\n            previous_is_emoji = False\n            previous_is_zwj = False\n            yield from accumulator\n            if not emoji_only:\n                yield token\n            accumulator = []\n    yield from accumulator\n\n\ndef get_search_tree() -> Dict[str, Any]:\n    \"\"\"\n    Generate a search tree for demojize().\n    Example of a search tree::\n\n        EMOJI_DATA =\n        {'a': {'en': ':Apple:'},\n        'b': {'en': ':Bus:'},\n        'ba': {'en': ':Bat:'},\n        'band': {'en': ':Beatles:'},\n        'bandit': {'en': ':Outlaw:'},\n        'bank': {'en': ':BankOfEngland:'},\n        'bb': {'en': ':BB-gun:'},\n        'c': {'en': ':Car:'}}\n\n        _SEARCH_TREE =\n        {'a': {'data': {'en': ':Apple:'}},\n        'b': {'a': {'data': {'en': ':Bat:'},\n                    'n': {'d': {'data': {'en': ':Beatles:'},\n                                'i': {'t': {'data': {'en': ':Outlaw:'}}}},\n                        'k': {'data': {'en': ':BankOfEngland:'}}}},\n            'b': {'data': {'en': ':BB-gun:'}},\n            'data': {'en': ':Bus:'}},\n        'c': {'data': {'en': ':Car:'}}}\n\n                   _SEARCH_TREE\n                 /     |        \u29f5\n               /       |          \u29f5\n            a          b             c\n            |        / |  \u29f5          |\n            |       /  |    \u29f5        |\n        :Apple:   ba  :Bus:  bb     :Car:\n                 /  \u29f5         |\n                /    \u29f5        |\n              :Bat:    ban     :BB-gun:\n                     /     \u29f5\n                    /       \u29f5\n                 band       bank\n                /   \u29f5         |\n               /     \u29f5        |\n            bandi :Beatles:  :BankOfEngland:\n               |\n            bandit\n               |\n           :Outlaw:\n\n\n    \"\"\"\n    if not _SEARCH_TREE:\n        for emj in unicode_codes.EMOJI_DATA:\n            sub_tree = _SEARCH_TREE\n            lastidx = len(emj) - 1\n            for i, char in enumerate(emj):\n                if char not in sub_tree:\n                    sub_tree[char] = {}\n                sub_tree = sub_tree[char]\n                if i == lastidx:\n                    sub_tree['data'] = unicode_codes.EMOJI_DATA[emj]\n    return _SEARCH_TREE\n"
    },
    {
      "@type": "CodeFile",
      "name": "__init__.py",
      "programmingLanguage": "Python",
      "text": "__all__ = [\n    # emoji.core\n    'emojize',\n    'demojize',\n    'analyze',\n    'config',\n    'emoji_list',\n    'distinct_emoji_list',\n    'emoji_count',\n    'replace_emoji',\n    'is_emoji',\n    'purely_emoji',\n    'version',\n    'Token',\n    'EmojiMatch',\n    'EmojiMatchZWJ',\n    'EmojiMatchZWJNonRGI',\n    # emoji.unicode_codes\n    'EMOJI_DATA',\n    'STATUS',\n    'LANGUAGES',\n]\n\n__version__ = '2.14.1'\n__author__ = 'Taehoon Kim, Kevin Wurster'\n__email__ = 'carpedm20@gmail.com'\n# and wursterk@gmail.com, tahir.jalilov@gmail.com\n__source__ = 'https://github.com/carpedm20/emoji/'\n__license__ = \"\"\"\nNew BSD License\n\nCopyright (c) 2014-2025, Taehoon Kim, Kevin Wurster\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* The names of its contributors may not be used to endorse or promote products\n  derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n\nfrom emoji.core import *\nfrom emoji.unicode_codes import *\n"
    },
    {
      "@type": "CodeFile",
      "name": "core.py",
      "programmingLanguage": "Python",
      "text": "\"\"\"\nemoji.core\n~~~~~~~~~~\n\nCore components for emoji.\n\n\"\"\"\n\nimport re\nimport unicodedata\nimport sys\nfrom typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union\n\nif sys.version_info < (3, 9):\n    from typing_extensions import Literal, Match, TypedDict  # type: ignore\nelse:\n    from typing import Literal, Match, TypedDict\n\nfrom emoji import unicode_codes\nfrom emoji.tokenizer import (\n    Token,\n    EmojiMatch,\n    EmojiMatchZWJ,\n    EmojiMatchZWJNonRGI,\n    tokenize,\n    filter_tokens,\n)\n\n__all__ = [\n    'emojize',\n    'demojize',\n    'analyze',\n    'config',\n    'emoji_list',\n    'distinct_emoji_list',\n    'emoji_count',\n    'replace_emoji',\n    'is_emoji',\n    'purely_emoji',\n    'version',\n    'Token',\n    'EmojiMatch',\n    'EmojiMatchZWJ',\n    'EmojiMatchZWJNonRGI',\n]\n\n_DEFAULT_DELIMITER = ':'\n# In Arabic language, the unicode character \"\\u0655\" should be kept so we add it to the pattern below\n_EMOJI_NAME_PATTERN = '\\\\w\\\\-&.\u2019\u201d\u201c()!#*+,/\u00ab\u00bb\\u0300\\u0301\\u0302\\u0303\\u0306\\u0308\\u030a\\u0327\\u064b\\u064e\\u064f\\u0650\\u0653\\u0654\\u3099\\u30fb\\u309a\\u0655'\n\n\nclass _EmojiListReturn(TypedDict):\n    emoji: str\n    match_start: int\n    match_end: int\n\n\nclass config:\n    \"\"\"Module-wide configuration\"\"\"\n\n    demojize_keep_zwj = True\n    \"\"\"Change the behavior of :func:`emoji.demojize()` regarding\n    zero-width-joiners (ZWJ/``\\\\u200D``) in emoji that are not\n    \"recommended for general interchange\" (non-RGI).\n    It has no effect on RGI emoji.\n\n    For example this family emoji with different skin tones \"\ud83d\udc68\u200d\ud83d\udc69\ud83c\udfff\u200d\ud83d\udc67\ud83c\udffb\u200d\ud83d\udc66\ud83c\udffe\" contains four\n    person emoji that are joined together by three ZWJ characters:\n    ``\ud83d\udc68\\\\u200D\ud83d\udc69\ud83c\udfff\\\\u200D\ud83d\udc67\ud83c\udffb\\\\u200D\ud83d\udc66\ud83c\udffe``\n\n    If ``True``, the zero-width-joiners will be kept and :func:`emoji.emojize()` can\n    reverse the :func:`emoji.demojize()` operation:\n    ``emoji.emojize(emoji.demojize(s)) == s``\n\n    The example emoji would be converted to\n    ``:man:\\\\u200d:woman_dark_skin_tone:\\\\u200d:girl_light_skin_tone:\\\\u200d:boy_medium-dark_skin_tone:``\n\n    If ``False``, the zero-width-joiners will be removed and :func:`emoji.emojize()`\n    can only reverse the individual emoji: ``emoji.emojize(emoji.demojize(s)) != s``\n\n    The example emoji would be converted to\n    ``:man::woman_dark_skin_tone::girl_light_skin_tone::boy_medium-dark_skin_tone:``\n    \"\"\"\n\n    replace_emoji_keep_zwj = False\n    \"\"\"Change the behavior of :func:`emoji.replace_emoji()` regarding\n    zero-width-joiners (ZWJ/``\\\\u200D``) in emoji that are not\n    \"recommended for general interchange\" (non-RGI).\n    It has no effect on RGI emoji.\n\n    See :attr:`config.demojize_keep_zwj` for more information.\n    \"\"\"\n\n    @staticmethod\n    def load_language(language: Union[List[str], str, None] = None):\n        \"\"\"Load one or multiple languages into memory.\n        If no language is specified, all languages will be loaded.\n\n        This makes language data accessible in the :data:`EMOJI_DATA` dict.\n        For example to access a French emoji name, first load French with\n\n         ``emoji.config.load_language('fr')``\n\n        and then access it with\n\n         ``emoji.EMOJI_DATA['\ud83c\udfc4']['fr']``\n\n        Available languages are listed in :data:`LANGUAGES`\"\"\"\n\n        languages = (\n            [language]\n            if isinstance(language, str)\n            else language\n            if language\n            else unicode_codes.LANGUAGES\n        )\n\n        for lang in languages:\n            unicode_codes.load_from_json(lang)\n\n\ndef emojize(\n    string: str,\n    delimiters: Tuple[str, str] = (_DEFAULT_DELIMITER, _DEFAULT_DELIMITER),\n    variant: Optional[Literal['text_type', 'emoji_type']] = None,\n    language: str = 'en',\n    version: Optional[float] = None,\n    handle_version: Optional[Union[str, Callable[[str, Dict[str, str]], str]]] = None,\n) -> str:\n    \"\"\"\n    Replace emoji names in a string with Unicode codes.\n        >>> import emoji\n        >>> print(emoji.emojize(\"Python is fun :thumbsup:\", language='alias'))\n        Python is fun \ud83d\udc4d\n        >>> print(emoji.emojize(\"Python is fun :thumbs_up:\"))\n        Python is fun \ud83d\udc4d\n        >>> print(emoji.emojize(\"Python is fun {thumbs_up}\", delimiters = (\"{\", \"}\")))\n        Python is fun \ud83d\udc4d\n        >>> print(emoji.emojize(\"Python is fun :red_heart:\", variant=\"text_type\"))\n        Python is fun \u2764\n        >>> print(emoji.emojize(\"Python is fun :red_heart:\", variant=\"emoji_type\"))\n        Python is fun \u2764\ufe0f # red heart, not black heart\n\n    :param string: String contains emoji names.\n    :param delimiters: (optional) Use delimiters other than _DEFAULT_DELIMITER. Each delimiter\n        should contain at least one character that is not part of a-zA-Z0-9 and ``_-&.()!?#*+,``.\n        See ``emoji.core._EMOJI_NAME_PATTERN`` for the regular expression of unsafe characters.\n    :param variant: (optional) Choose variation selector between \"base\"(None), VS-15 (\"text_type\") and VS-16 (\"emoji_type\")\n    :param language: Choose language of emoji name: language code 'es', 'de', etc. or 'alias'\n        to use English aliases\n    :param version: (optional) Max version. If set to an Emoji Version,\n        all emoji above this version will be ignored.\n    :param handle_version: (optional) Replace the emoji above ``version``\n        instead of ignoring it. handle_version can be either a string or a\n        callable; If it is a callable, it's passed the Unicode emoji and the\n        data dict from :data:`EMOJI_DATA` and must return a replacement string\n        to be used::\n\n            handle_version('\\\\U0001F6EB', {\n                'en' : ':airplane_departure:',\n                'status' : fully_qualified,\n                'E' : 1,\n                'alias' : [':flight_departure:'],\n                'de': ':abflug:',\n                'es': ':avi\u00f3n_despegando:',\n                ...\n            })\n\n    :raises ValueError: if ``variant`` is neither None, 'text_type' or 'emoji_type'\n\n    \"\"\"\n\n    unicode_codes.load_from_json(language)\n\n    pattern = re.compile(\n        '(%s[%s]+%s)'\n        % (re.escape(delimiters[0]), _EMOJI_NAME_PATTERN, re.escape(delimiters[1]))\n    )\n\n    def replace(match: Match[str]) -> str:\n        name = match.group(1)[len(delimiters[0]) : -len(delimiters[1])]\n        emj = unicode_codes.get_emoji_by_name(\n            _DEFAULT_DELIMITER\n            + unicodedata.normalize('NFKC', name)\n            + _DEFAULT_DELIMITER,\n            language,\n        )\n\n        if emj is None:\n            return match.group(1)\n\n        if version is not None and unicode_codes.EMOJI_DATA[emj]['E'] > version:\n            if callable(handle_version):\n                emj_data = unicode_codes.EMOJI_DATA[emj].copy()\n                emj_data['match_start'] = match.start()\n                emj_data['match_end'] = match.end()\n                return handle_version(emj, emj_data)\n\n            elif handle_version is not None:\n                return str(handle_version)\n            else:\n                return ''\n\n        if variant is None or 'variant' not in unicode_codes.EMOJI_DATA[emj]:\n            return emj\n\n        if emj[-1] == '\\ufe0e' or emj[-1] == '\\ufe0f':\n            # Remove an existing variant\n            emj = emj[0:-1]\n        if variant == 'text_type':\n            return emj + '\\ufe0e'\n        elif variant == 'emoji_type':\n            return emj + '\\ufe0f'\n        else:\n            raise ValueError(\n                \"Parameter 'variant' must be either None, 'text_type' or 'emoji_type'\"\n            )\n\n    return pattern.sub(replace, string)\n\n\ndef analyze(\n    string: str, non_emoji: bool = False, join_emoji: bool = True\n) -> Iterator[Token]:\n    \"\"\"\n    Find unicode emoji in a string. Yield each emoji as a named tuple\n    :class:`Token` ``(chars, EmojiMatch)`` or :class:`Token` ``(chars, EmojiMatchZWJNonRGI)``.\n    If ``non_emoji`` is True, also yield all other characters as\n    :class:`Token` ``(char, char)`` .\n\n    :param string: String to analyze\n    :param non_emoji: If True also yield all non-emoji characters as Token(char, char)\n    :param join_emoji: If True, multiple EmojiMatch are merged into a single\n        EmojiMatchZWJNonRGI if they are separated only by a ZWJ.\n    \"\"\"\n\n    return filter_tokens(\n        tokenize(string, keep_zwj=True), emoji_only=not non_emoji, join_emoji=join_emoji\n    )\n\n\ndef demojize(\n    string: str,\n    delimiters: Tuple[str, str] = (_DEFAULT_DELIMITER, _DEFAULT_DELIMITER),\n    language: str = 'en',\n    version: Optional[float] = None,\n    handle_version: Optional[Union[str, Callable[[str, Dict[str, str]], str]]] = None,\n) -> str:\n    \"\"\"\n    Replace Unicode emoji in a string with emoji shortcodes. Useful for storage.\n        >>> import emoji\n        >>> print(emoji.emojize(\"Python is fun :thumbs_up:\"))\n        Python is fun \ud83d\udc4d\n        >>> print(emoji.demojize(\"Python is fun \ud83d\udc4d\"))\n        Python is fun :thumbs_up:\n        >>> print(emoji.demojize(\"icode is tricky \ud83d\ude2f\", delimiters=(\"__\", \"__\")))\n        Unicode is tricky __hushed_face__\n\n    :param string: String contains Unicode characters. MUST BE UNICODE.\n    :param delimiters: (optional) User delimiters other than ``_DEFAULT_DELIMITER``\n    :param language: Choose language of emoji name: language code 'es', 'de', etc. or 'alias'\n        to use English aliases\n    :param version: (optional) Max version. If set to an Emoji Version,\n        all emoji above this version will be removed.\n    :param handle_version: (optional) Replace the emoji above ``version``\n        instead of removing it. handle_version can be either a string or a\n        callable ``handle_version(emj: str, data: dict) -> str``; If it is\n        a callable, it's passed the Unicode emoji and the data dict from\n        :data:`EMOJI_DATA` and must return a replacement string  to be used.\n        The passed data is in the form of::\n\n            handle_version('\\\\U0001F6EB', {\n                'en' : ':airplane_departure:',\n                'status' : fully_qualified,\n                'E' : 1,\n                'alias' : [':flight_departure:'],\n                'de': ':abflug:',\n                'es': ':avi\u00f3n_despegando:',\n                ...\n            })\n\n    \"\"\"\n\n    if language == 'alias':\n        language = 'en'\n        _use_aliases = True\n    else:\n        _use_aliases = False\n\n    unicode_codes.load_from_json(language)\n\n    def handle(emoji_match: EmojiMatch) -> str:\n        assert emoji_match.data is not None\n        if version is not None and emoji_match.data['E'] > version:\n            if callable(handle_version):\n                return handle_version(emoji_match.emoji, emoji_match.data_copy())\n            elif handle_version is not None:\n                return handle_version\n            else:\n                return ''\n        elif language in emoji_match.data:\n            if _use_aliases and 'alias' in emoji_match.data:\n                return (\n                    delimiters[0] + emoji_match.data['alias'][0][1:-1] + delimiters[1]\n                )\n            else:\n                return delimiters[0] + emoji_match.data[language][1:-1] + delimiters[1]\n        else:\n            # The emoji exists, but it is not translated, so we keep the emoji\n            return emoji_match.emoji\n\n    matches = tokenize(string, keep_zwj=config.demojize_keep_zwj)\n    return ''.join(\n        str(handle(token.value)) if isinstance(token.value, EmojiMatch) else token.value\n        for token in matches\n    )\n\n\ndef replace_emoji(\n    string: str,\n    replace: Union[str, Callable[[str, Dict[str, str]], str]] = '',\n    version: float = -1,\n) -> str:\n    \"\"\"\n    Replace Unicode emoji in a customizable string.\n\n    :param string: String contains Unicode characters. MUST BE UNICODE.\n    :param replace: (optional) replace can be either a string or a callable;\n        If it is a callable, it's passed the Unicode emoji and the data dict from\n        :data:`EMOJI_DATA` and must return a replacement string to be used.\n        replace(str, dict) -> str\n    :param version: (optional) Max version. If set to an Emoji Version,\n        only emoji above this version will be replaced.\n    \"\"\"\n\n    def handle(emoji_match: EmojiMatch) -> str:\n        if version > -1:\n            assert emoji_match.data is not None\n            if emoji_match.data['E'] > version:\n                if callable(replace):\n                    return replace(emoji_match.emoji, emoji_match.data_copy())\n                else:\n                    return str(replace)\n        elif callable(replace):\n            return replace(emoji_match.emoji, emoji_match.data_copy())\n        elif replace is not None:  # type: ignore\n            return replace\n        return emoji_match.emoji\n\n    matches = tokenize(string, keep_zwj=config.replace_emoji_keep_zwj)\n    if config.replace_emoji_keep_zwj:\n        matches = filter_tokens(matches, emoji_only=False, join_emoji=True)\n    return ''.join(\n        str(handle(m.value)) if isinstance(m.value, EmojiMatch) else m.value\n        for m in matches\n    )\n\n\ndef emoji_list(string: str) -> List[_EmojiListReturn]:\n    \"\"\"\n    Returns the location and emoji in list of dict format.\n        >>> emoji.emoji_list(\"Hi, I am fine. \ud83d\ude01\")\n        [{'match_start': 15, 'match_end': 16, 'emoji': '\ud83d\ude01'}]\n    \"\"\"\n\n    return [\n        {\n            'match_start': m.value.start,\n            'match_end': m.value.end,\n            'emoji': m.value.emoji,\n        }\n        for m in tokenize(string, keep_zwj=False)\n        if isinstance(m.value, EmojiMatch)\n    ]\n\n\ndef distinct_emoji_list(string: str) -> List[str]:\n    \"\"\"Returns distinct list of emojis from the string.\"\"\"\n    distinct_list = list({e['emoji'] for e in emoji_list(string)})\n    return distinct_list\n\n\ndef emoji_count(string: str, unique: bool = False) -> int:\n    \"\"\"\n    Returns the count of emojis in a string.\n\n    :param unique: (optional) True if count only unique emojis\n    \"\"\"\n    if unique:\n        return len(distinct_emoji_list(string))\n    return len(emoji_list(string))\n\n\ndef is_emoji(string: str) -> bool:\n    \"\"\"\n    Returns True if the string is a single emoji, and it is \"recommended for\n    general interchange\" by Unicode.org.\n    \"\"\"\n    return string in unicode_codes.EMOJI_DATA\n\n\ndef purely_emoji(string: str) -> bool:\n    \"\"\"\n    Returns True if the string contains only emojis.\n    This might not imply that `is_emoji` for all the characters, for example,\n    if the string contains variation selectors.\n    \"\"\"\n    return all(isinstance(m.value, EmojiMatch) for m in analyze(string, non_emoji=True))\n\n\ndef version(string: str) -> float:\n    \"\"\"\n    Returns the Emoji Version of the emoji.\n\n    See https://www.unicode.org/reports/tr51/#Versioning for more information.\n        >>> emoji.version(\"\ud83d\ude01\")\n        0.6\n        >>> emoji.version(\":butterfly:\")\n        3\n\n    :param string: An emoji or a text containing an emoji\n    :raises ValueError: if ``string`` does not contain an emoji\n    \"\"\"\n    # Try dictionary lookup\n    if string in unicode_codes.EMOJI_DATA:\n        return unicode_codes.EMOJI_DATA[string]['E']\n\n    # Try name lookup\n    emj_code = unicode_codes.get_emoji_by_name(string, 'en')\n    if emj_code and emj_code in unicode_codes.EMOJI_DATA:\n        return unicode_codes.EMOJI_DATA[emj_code]['E']\n\n    # Try to find first emoji in string\n    version: List[float] = []\n\n    def f(e: str, emoji_data: Dict[str, Any]) -> str:\n        version.append(emoji_data['E'])\n        return ''\n\n    replace_emoji(string, replace=f, version=-1)\n    if version:\n        return version[0]\n    emojize(string, language='alias', version=-1, handle_version=f)\n    if version:\n        return version[0]\n    for lang_code in unicode_codes.LANGUAGES:\n        emojize(string, language=lang_code, version=-1, handle_version=f)\n        if version:\n            return version[0]\n\n    raise ValueError('No emoji found in string')\n"
    },
    {
      "@type": "CodeFile",
      "name": "unicode_codes/__init__.py",
      "programmingLanguage": "Python",
      "text": "import sys\nimport importlib.resources\nimport json\nfrom functools import lru_cache\nfrom warnings import warn\n\nfrom typing import Any, BinaryIO, Dict, List, Optional\n\nfrom emoji.unicode_codes.data_dict import STATUS, LANGUAGES\n\n__all__ = [\n    'get_emoji_by_name',\n    'load_from_json',\n    'EMOJI_DATA',\n    'STATUS',\n    'LANGUAGES',\n]\n\n_DEFAULT_KEYS = ('en', 'alias', 'E', 'status')  # The keys in emoji.json\n\n_loaded_keys: List[str] = list(\n    _DEFAULT_KEYS\n)  # Keep track of keys already loaded from json files to avoid loading them twice\n\n\n@lru_cache(maxsize=4000)\ndef get_emoji_by_name(name: str, language: str) -> Optional[str]:\n    \"\"\"\n    Find emoji by short-name in a specific language.\n    Returns None if not found\n\n    :param name: emoji short code e.g. \":banana:\"\n    :param language: language-code e.g. 'es', 'de', etc. or 'alias'\n    \"\"\"\n\n    fully_qualified = STATUS['fully_qualified']\n\n    if language == 'alias':\n        for emj, data in EMOJI_DATA.items():\n            if name in data.get('alias', []) and data['status'] <= fully_qualified:\n                return emj\n        language = 'en'\n\n    for emj, data in EMOJI_DATA.items():\n        if data.get(language) == name and data['status'] <= fully_qualified:\n            return emj\n\n    return None\n\n\nclass EmojiDataDict(Dict[str, Any]):\n    \"\"\"Replaces built-in-dict in the values of the EMOJI_DATA dict.\n    Auto loads language data when accessing language data via\n    key-access without prior loading of the language:\n    e.g. EMOJI_DATA['\ud83d\udc4c']['fr'] will auto load French language and not throw\n    a KeyError.\n    Shows a deprecation warning explainging that `emoji.config.load_language()`\n    should be used.\"\"\"\n\n    def __missing__(self, key: str) -> str:\n        \"\"\"Auto load language `key`, raises KeyError if language is no supported.\"\"\"\n        if key in LANGUAGES and key not in _loaded_keys:\n            load_from_json(key)\n            if key in self:\n                warn(\n                    f\"\"\"Use emoji.config.load_language('{key}') before accesing EMOJI_DATA[emj]['{key}'].\nAccessing EMOJI_DATA[emj]['{key}'] without loading the language is deprecated.\"\"\",\n                    DeprecationWarning,\n                    stacklevel=3,\n                )\n                return self[key]  # type: ignore\n\n        raise KeyError(key)\n\n\nEMOJI_DATA: Dict[str, Dict[str, Any]]\n\n\ndef _open_file(name: str) -> BinaryIO:\n    if sys.version_info >= (3, 9):\n        return importlib.resources.files('emoji.unicode_codes').joinpath(name).open('rb')\n    else:\n        return importlib.resources.open_binary('emoji.unicode_codes', name)\n\n\ndef _load_default_from_json():\n    global EMOJI_DATA\n    global _loaded_keys\n\n    with _open_file('emoji.json') as f:\n        EMOJI_DATA = dict(json.load(f, object_pairs_hook=EmojiDataDict))  # type: ignore\n    _loaded_keys = list(_DEFAULT_KEYS)\n\n\ndef load_from_json(key: str):\n    \"\"\"Load values from the file 'emoji_{key}.json' into EMOJI_DATA\"\"\"\n\n    if key in _loaded_keys:\n        return\n\n    if key not in LANGUAGES:\n        raise NotImplementedError('Language not supported', key)\n\n    with _open_file(f'emoji_{key}.json') as f:\n        for emj, value in json.load(f).items():\n            EMOJI_DATA[emj][key] = value  # type: ignore\n\n    _loaded_keys.append(key)\n\n\n_load_default_from_json()\n"
    },
    {
      "@type": "CodeFile",
      "name": "unicode_codes/data_dict.py",
      "programmingLanguage": "Python",
      "text": "\"\"\"Data containing all current emoji\nExtracted from https://unicode.org/Public/emoji/latest/emoji-test.txt\nand https://www.unicode.org/Public/UCD/latest/ucd/emoji/emoji-variation-sequences.txt\nSee utils/generate_emoji.py\n\n+----------------+-------------+------------------+-------------------+\n| Emoji Version  |    Date     | Unicode Version  | Data File Comment |\n+----------------+-------------+------------------+-------------------+\n| N/A            | 2010-10-11  | Unicode 6.0      | E0.6              |\n| N/A            | 2014-06-16  | Unicode 7.0      | E0.7              |\n| Emoji 1.0      | 2015-06-09  | Unicode 8.0      | E1.0              |\n| Emoji 2.0      | 2015-11-12  | Unicode 8.0      | E2.0              |\n| Emoji 3.0      | 2016-06-03  | Unicode 9.0      | E3.0              |\n| Emoji 4.0      | 2016-11-22  | Unicode 9.0      | E4.0              |\n| Emoji 5.0      | 2017-06-20  | Unicode 10.0     | E5.0              |\n| Emoji 11.0     | 2018-05-21  | Unicode 11.0     | E11.0             |\n| Emoji 12.0     | 2019-03-05  | Unicode 12.0     | E12.0             |\n| Emoji 12.1     | 2019-10-21  | Unicode 12.1     | E12.1             |\n| Emoji 13.0     | 2020-03-10  | Unicode 13.0     | E13.0             |\n| Emoji 13.1     | 2020-09-15  | Unicode 13.0     | E13.1             |\n| Emoji 14.0     | 2021-09-14  | Unicode 14.0     | E14.0             |\n| Emoji 15.0     | 2022-09-13  | Unicode 15.0     | E15.0             |\n| Emoji 15.1     | 2023-09-12  | Unicode 15.1     | E15.1             |\n| Emoji 16.0     | 2024-09-10  | Unicode 16.0     | E16.0             |\n\n               http://www.unicode.org/reports/tr51/#Versioning\n\n\"\"\"\n\n__all__ = ['STATUS', 'LANGUAGES']\n\nfrom typing import Any, Dict, List\n\n\ncomponent = 1\nfully_qualified = 2\nminimally_qualified = 3\nunqualified = 4\n\nSTATUS: Dict[str, int] = {\n    'component': component,\n    'fully_qualified': fully_qualified,\n    'minimally_qualified': minimally_qualified,\n    'unqualified': unqualified,\n}\n\nLANGUAGES: List[str] = [\n    'en',\n    'es',\n    'ja',\n    'ko',\n    'pt',\n    'it',\n    'fr',\n    'de',\n    'fa',\n    'id',\n    'zh',\n    'ru',\n    'tr',\n    'ar',\n]\n\n\n# The following is only an example of how the EMOJI_DATA dict is structured.\n# The real data is loaded from the json files at runtime, see unicode_codes/__init__.py\nEMOJI_DATA: Dict[str, Dict[str, Any]] = {\n    '\\U0001f947': {  # \ud83e\udd47\n        'en': ':1st_place_medal:',\n        'status': fully_qualified,\n        'E': 3,\n        'de': ':goldmedaille:',\n        'es': ':medalla_de_oro:',\n        'fr': ':m\u00e9daille_d\u2019or:',\n        'ja': ':\u91d1\u30e1\u30c0\u30eb:',\n        'ko': ':\uae08\uba54\ub2ec:',\n        'pt': ':medalha_de_ouro:',\n        'it': ':medaglia_d\u2019oro:',\n        'fa': ':\u0645\u062f\u0627\u0644_\u0637\u0644\u0627:',\n        'id': ':medali_emas:',\n        'zh': ':\u91d1\u724c:',\n        'ru': ':\u0437\u043e\u043b\u043e\u0442\u0430\u044f_\u043c\u0435\u0434\u0430\u043b\u044c:',\n        'tr': ':birincilik_madalyas\u0131:',\n        'ar': ':\u0645\u064a\u062f\u0627\u0644\u064a\u0629_\u0645\u0631\u0643\u0632_\u0623\u0648\u0644:',\n    },\n    '\\U0001f948': {  # \ud83e\udd48\n        'en': ':2nd_place_medal:',\n        'status': fully_qualified,\n        'E': 3,\n        'de': ':silbermedaille:',\n        'es': ':medalla_de_plata:',\n        'fr': ':m\u00e9daille_d\u2019argent:',\n        'ja': ':\u9280\u30e1\u30c0\u30eb:',\n        'ko': ':\uc740\uba54\ub2ec:',\n        'pt': ':medalha_de_prata:',\n        'it': ':medaglia_d\u2019argento:',\n        'fa': ':\u0645\u062f\u0627\u0644_\u0646\u0642\u0631\u0647:',\n        'id': ':medali_perak:',\n        'zh': ':\u94f6\u724c:',\n        'ru': ':\u0441\u0435\u0440\u0435\u0431\u0440\u044f\u043d\u0430\u044f_\u043c\u0435\u0434\u0430\u043b\u044c:',\n        'tr': ':ikincilik_madalyas\u0131:',\n        'ar': ':\u0645\u064a\u062f\u0627\u0644\u064a\u0629_\u0645\u0631\u0643\u0632_\u062b\u0627\u0646:',\n    },\n    '\\U0001f949': {  # \ud83e\udd49\n        'en': ':3rd_place_medal:',\n        'status': fully_qualified,\n        'E': 3,\n        'de': ':bronzemedaille:',\n        'es': ':medalla_de_bronce:',\n        'fr': ':m\u00e9daille_de_bronze:',\n        'ja': ':\u9285\u30e1\u30c0\u30eb:',\n        'ko': ':\ub3d9\uba54\ub2ec:',\n        'pt': ':medalha_de_bronze:',\n        'it': ':medaglia_di_bronzo:',\n        'fa': ':\u0645\u062f\u0627\u0644_\u0628\u0631\u0646\u0632:',\n        'id': ':medali_perunggu:',\n        'zh': ':\u94dc\u724c:',\n        'ru': ':\u0431\u0440\u043e\u043d\u0437\u043e\u0432\u0430\u044f_\u043c\u0435\u0434\u0430\u043b\u044c:',\n        'tr': ':\u00fc\u00e7\u00fcnc\u00fcl\u00fck_madalyas\u0131:',\n        'ar': ':\u0645\u064a\u062f\u0627\u0644\u064a\u0629_\u0645\u0631\u0643\u0632_\u062b\u0627\u0644\u062b:',\n    },\n    '\\U0001f18e': {  # \ud83c\udd8e\n        'en': ':AB_button_(blood_type):',\n        'status': fully_qualified,\n        'E': 0.6,\n        'alias': [':ab:', ':ab_button_blood_type:'],\n        'de': ':gro\u00dfbuchstaben_ab_in_rotem_quadrat:',\n        'es': ':grupo_sangu\u00edneo_ab:',\n        'fr': ':groupe_sanguin_ab:',\n        'ja': ':\u8840\u6db2\u578bab\u578b:',\n        'ko': ':\uc5d0\uc774\ube44\ud615:',\n        'pt': ':bot\u00e3o_ab_(tipo_sangu\u00edneo):',\n        'it': ':gruppo_sanguigno_ab:',\n        'fa': ':\u062f\u06a9\u0645\u0647_\u0622_\u0628_(\u06af\u0631\u0648\u0647_\u062e\u0648\u0646\u06cc):',\n        'id': ':tombol_ab_(golongan_darah):',\n        'zh': ':AB\u578b\u8840:',\n        'ru': ':IV_\u0433\u0440\u0443\u043f\u043f\u0430_\u043a\u0440\u043e\u0432\u0438:',\n        'tr': ':ab_d\u00fc\u011fmesi_(kan_grubu):',\n        'ar': ':\u0632\u0631_ab_(\u0641\u0626\u0629_\u0627\u0644\u062f\u0645):',\n    },\n    '\\U0001f3e7': {  # \ud83c\udfe7\n        'en': ':ATM_sign:',\n        'status': fully_qualified,\n        'E': 0.6,\n        'alias': [':atm:', ':atm_sign:'],\n        'de': ':symbol_geldautomat:',\n        'es': ':se\u00f1al_de_cajero_autom\u00e1tico:',\n        'fr': ':distributeur_de_billets:',\n        'ja': ':atm:',\n        'ko': ':\uc5d0\uc774\ud2f0\uc5e0:',\n        'pt': ':s\u00edmbolo_de_caixa_autom\u00e1tico:',\n        'it': ':simbolo_dello_sportello_bancomat:',\n        'fa': ':\u0646\u0634\u0627\u0646_\u0639\u0627\u0628\u0631\u0628\u0627\u0646\u06a9:',\n        'id': ':tanda_atm:',\n        'zh': ':\u53d6\u6b3e\u673a:',\n        'ru': ':\u0437\u043d\u0430\u0447\u043e\u043a_\u0431\u0430\u043d\u043a\u043e\u043c\u0430\u0442\u0430:',\n        'tr': ':atm_i\u015fareti:',\n        'ar': ':\u0639\u0644\u0627\u0645\u0629_\u0645\u0627\u0643\u064a\u0646\u0629_\u0635\u0631\u0641_\u0622\u0644\u064a:',\n    },\n    '\\U0001f170\\U0000fe0f': {  # \ud83c\udd70\ufe0f\n        'en': ':A_button_(blood_type):',\n        'status': fully_qualified,\n        'E': 0.6,\n        'alias': [':a:', ':a_button_blood_type:'],\n        'variant': True,\n        'de': ':gro\u00dfbuchstabe_a_in_rotem_quadrat:',\n        'es': ':grupo_sangu\u00edneo_a:',\n        'fr': ':groupe_sanguin_a:',\n        'ja': ':\u8840\u6db2\u578ba\u578b:',\n        'ko': ':\uc5d0\uc774\ud615:',\n        'pt': ':bot\u00e3o_a_(tipo_sangu\u00edneo):',\n        'it': ':gruppo_sanguigno_a:',\n        'fa': ':\u062f\u06a9\u0645\u0647_\u0622_(\u06af\u0631\u0648\u0647_\u062e\u0648\u0646\u06cc):',\n        'id': ':tombol_a_(golongan_darah):',\n        'zh': ':A\u578b\u8840:',\n        'ru': ':ii_\u0433\u0440\u0443\u043f\u043f\u0430_\u043a\u0440\u043e\u0432\u0438:',\n        'tr': ':a_d\u00fc\u011fmesi_(kan_grubu):',\n        'ar': ':\u0632\u0631_a:',\n    },\n    '\\U0001f170': {  # \ud83c\udd70\n        'en': ':A_button_(blood_type):',\n        'status': unqualified,\n        'E': 0.6,\n        'alias': [':a:', ':a_button_blood_type:'],\n        'variant': True,\n        'de': ':gro\u00dfbuchstabe_a_in_rotem_quadrat:',\n        'es': ':grupo_sangu\u00edneo_a:',\n        'fr': ':groupe_sanguin_a:',\n        'ja': ':\u8840\u6db2\u578ba\u578b:',\n        'ko': ':\uc5d0\uc774\ud615:',\n        'pt': ':bot\u00e3o_a_(tipo_sangu\u00edneo):',\n        'it': ':gruppo_sanguigno_a:',\n        'fa': ':\u062f\u06a9\u0645\u0647_\u0622_(\u06af\u0631\u0648\u0647_\u062e\u0648\u0646\u06cc):',\n        'id': ':tombol_a_(golongan_darah):',\n        'zh': ':A\u578b\u8840:',\n        'ru': ':II_\u0433\u0440\u0443\u043f\u043f\u0430_\u043a\u0440\u043e\u0432\u0438:',\n        'tr': ':a_d\u00fc\u011fmesi_(kan_grubu):',\n        'ar': ':\u0632\u0631_a:',\n    },\n    '\\U0001f1e6\\U0001f1eb': {  # \ud83c\udde6\ud83c\uddeb\n        'en': ':Afghanistan:',\n        'status': fully_qualified,\n        'E': 2,\n        'alias': [':flag_for_Afghanistan:', ':afghanistan:'],\n        'de': ':flagge_afghanistan:',\n        'es': ':bandera_afganist\u00e1n:',\n        'fr': ':drapeau_afghanistan:',\n        'ja': ':\u65d7_\u30a2\u30d5\u30ac\u30cb\u30b9\u30bf\u30f3:',\n        'ko': ':\uae43\ubc1c_\uc544\ud504\uac00\ub2c8\uc2a4\ud0c4:',\n        'pt': ':bandeira_afeganist\u00e3o:',\n        'it': ':bandiera_afghanistan:',\n        'fa': ':\u067e\u0631\u0686\u0645_\u0627\u0641\u063a\u0627\u0646\u0633\u062a\u0627\u0646:',\n        'id': ':bendera_afganistan:',\n        'zh': ':\u963f\u5bcc\u6c57:',\n        'ru': ':\u0444\u043b\u0430\u0433_\u0410\u0444\u0433\u0430\u043d\u0438\u0441\u0442\u0430\u043d:',\n        'tr': ':bayrak_afganistan:',\n        'ar': ':\u0639\u0644\u0645_\u0623\u0641\u063a\u0627\u0646\u0633\u062a\u0627\u0646:',\n    },\n    '\\U0001f1e6\\U0001f1f1': {  # \ud83c\udde6\ud83c\uddf1\n        'en': ':Albania:',\n        'status': fully_qualified,\n        'E': 2,\n        'alias': [':flag_for_Albania:', ':albania:'],\n        'de': ':flagge_albanien:',\n        'es': ':bandera_albania:',\n        'fr': ':drapeau_albanie:',\n        'ja': ':\u65d7_\u30a2\u30eb\u30d0\u30cb\u30a2:',\n        'ko': ':\uae43\ubc1c_\uc54c\ubc14\ub2c8\uc544:',\n        'pt': ':bandeira_alb\u00e2nia:',\n        'it': ':bandiera_albania:',\n        'fa': ':\u067e\u0631\u0686\u0645_\u0622\u0644\u0628\u0627\u0646\u06cc:',\n        'id': ':bendera_albania:',\n        'zh': ':\u963f\u5c14\u5df4\u5c3c\u4e9a:',\n        'ru': ':\u0444\u043b\u0430\u0433_\u0410\u043b\u0431\u0430\u043d\u0438\u044f:',\n        'tr': ':bayrak_arnavutluk:',\n        'ar': ':\u0639\u0644\u0645_\u0623\u0644\u0628\u0627\u0646\u064a\u0627:',\n    },\n    '\\U0001f1e9\\U0001f1ff': {  # \ud83c\udde9\ud83c\uddff\n        'en': ':Algeria:',\n        'status': fully_qualified,\n        'E': 2,\n        'alias': [':flag_for_Algeria:', ':algeria:'],\n        'de': ':flagge_algerien:',\n        'es': ':bandera_argelia:',\n        'fr': ':drapeau_alg\u00e9rie:',\n        'ja': ':\u65d7_\u30a2\u30eb\u30b8\u30a7\u30ea\u30a2:',\n        'ko': ':\uae43\ubc1c_\uc54c\uc81c\ub9ac:',\n        'pt': ':bandeira_arg\u00e9lia:',\n        'it': ':bandiera_algeria:',\n        'fa': ':\u067e\u0631\u0686\u0645_\u0627\u0644\u062c\u0632\u0627\u06cc\u0631:',\n        'id': ':bendera_aljazair:',\n        'zh': ':\u963f\u5c14\u53ca\u5229\u4e9a:',\n        'ru': ':\u0444\u043b\u0430\u0433_\u0410\u043b\u0436\u0438\u0440:',\n        'tr': ':bayrak_cezayir:',\n        'ar': ':\u0639\u0644\u0645_\u0627\u0644\u062c\u0632\u0627\u0626\u0631:',\n    },\n    '\\U0001f1e6\\U0001f1f8': {  # \ud83c\udde6\ud83c\uddf8\n        'en': ':American_Samoa:',\n        'status': fully_qualified,\n        'E': 2,\n        'alias': [':flag_for_American_Samoa:', ':american_samoa:'],\n        'de': ':flagge_amerikanisch-samoa:',\n        'es': ':bandera_samoa_americana:',\n        'fr': ':drapeau_samoa_am\u00e9ricaines:',\n        'ja': ':\u65d7_\u7c73\u9818\u30b5\u30e2\u30a2:',\n        'ko': ':\uae43\ubc1c_\uc544\uba54\ub9ac\uce78_\uc0ac\ubaa8\uc544:',\n        'pt': ':bandeira_samoa_americana:',\n        'it': ':bandiera_samoa_americane:',\n        'fa': ':\u067e\u0631\u0686\u0645_\u0633\u0627\u0645\u0648\u0622\u06cc_\u0627\u0645\u0631\u06cc\u06a9\u0627:',\n        'id': ':bendera_samoa_amerika:',\n        'zh': ':\u7f8e\u5c5e\u8428\u6469\u4e9a:',\n        'ru': ':\u0444\u043b\u0430\u0433_\u0410\u043c\u0435\u0440\u0438\u043a\u0430\u043d\u0441\u043a\u043e\u0435_\u0421\u0430\u043c\u043e\u0430:',\n        'tr': ':bayrak_amerikan_samoas\u0131:',\n        'ar': ':\u0639\u0644\u0645_\u0633\u0627\u0645\u0648\u0627_\u0627\u0644\u0623\u0645\u0631\u064a\u0643\u064a\u0629:',\n    },\n}\n"
    }
  ]
}